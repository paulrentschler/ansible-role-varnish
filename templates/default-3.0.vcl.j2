#
# {{ ansible_managed }}
#
# This is a VCL configuration file for varnish 3.x.  See the vcl(7)
# man page for details on VCL syntax and semantics.
#

# Define our zope clients with health checks
{% for i in range(varnish_zope_clients) %}
backend zope{{ i }} {
    .host = "127.0.0.1";
    .port = "808{{ i }}";
{% if varnish_health_check_url is defined %}
    .probe = {
        .url = "{{ varnish_health_check_url }}";
        .interval = 10s;
        .timeout = 3s;
        .window = 3;
        .threshold = 3;
    }
{% endif %}
}
{% endfor %}


# Create a round-robin director called "zopecluster" which will talk to
# Plone's zope clients as backends.
director zopecluster round-robin {
{% for i in range(varnish_zope_clients) %}
    { .backend = zope{{ i }}; }
{% endfor %}
}


# This sets an access control list for an action we are calling "purge".
# Only localhost will be able to perform this "purge" action (detailed later).
acl purge {
    "localhost";
    "127.0.0.1";
}


# sub vcl_recv is called whenever a request is received by Varnish (i.e. a
# request is made for a webpage).
sub vcl_recv {
    # Use our round-robin "zopecluster" for the backend.
    set req.backend = zopecluster;

    # Serve objects up to 2 hours past their expiry if the Plone backend
    # is not responding and 3 minutes past their expiry if there is a
    # request pile-up.
    set req.grace = 900s;
    if (! req.backend.healthy) {
        set req.grace = 2h;
    } else {
        set req.grace = 3m;
    }

    # This uses the ACL action called "purge". Basically if a request to
    # PURGE the cache comes from anywhere other than localhost, ignore it.
    if (req.request == "PURGE") {
        if (!client.ip ~ purge) {
            error 405 "Not allowed.";
        }
        return(lookup);
    }

    # Pass any requests that Varnish does not understand straight to the
    # backend (Plone). Ignore any further parts of this request.
    if (req.request != "GET" &&
        req.request != "HEAD" &&
        req.request != "PUT" &&
        req.request != "POST" &&
        req.request != "TRACE" &&
        req.request != "OPTIONS" &&
        req.request != "DELETE") {
        # Non-RFC2616 or CONNECT which is weird.
        return(pipe);
    }

    # Pass anything other than GET and HEAD directly to Plone.
    if (req.request != "GET" && req.request != "HEAD") {
        # We only deal with GET and HEAD by default
        return(pass);
    }

    # Pass any requests with the "If-None-Match" header directly to Plone.
    if (req.http.If-None-Match) {
        return(pass);
    }

    remove req.http.Accept-Encoding;
    return(lookup);
}


sub vcl_pipe {
    # This is not necessary if you do not do any request rewriting.
    set req.http.connection = "close";
}


# Called if the cache has a copy of the page.
sub vcl_hit {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged";
    }

    # Force lookup if the request is a no-cache request from the client.
    if (req.http.Cache-Control ~ "no-cache") {
        purge;
        return(pass);
    }

    if (obj.ttl == 0s) {
        return(pass);
    }
}


# Called if the cache does not have a copy of the page.
sub vcl_miss {
    if (req.request == "PURGE") {
        purge;
        error 404 "Not in cache";
    }
}


# Called after a document has been successfully retrieved from the backend.
sub vcl_fetch {
    # saint mode to handle the situation where one zope throws a
    # 500 internal server error
    if (beresp.status == 500) {
        set beresp.saintmode = 10s;
        return(restart);
    }

    # hold objects in the cache 2 hours past their expiry (TTL)
    set beresp.grace = 2h;

    if (beresp.ttl == 0s) {
        set beresp.http.X-Varnish-Action = "FETCH (hit_for_pass - 0 TTL)";
        return(hit_for_pass);
    }
    if (beresp.http.Set-Cookie) {
        set beresp.http.X-Varnish-Action = "FETCH (hit_for_pass - response sets cookie)";
        return(hit_for_pass);
    }
    if (beresp.http.Cache-Control ~ "(private|no-cache|no-store)") {
        set beresp.http.X-Varnish-Action = "FETCH (hit_for_pass - response sets private/no-cache/no-store token)";
        return(hit_for_pass);
    }
    if (beresp.http.Authorization && !beresp.http.Cache-Control ~ "public") {
        set beresp.http.X-Varnish-Action = "FETCH (hit_for_pass - authorized and no public cache control)";
        return(hit_for_pass);
    }
}


# Called before a cached object is delivered to the client.
# In this case add an extra header to the HTTP response.
sub vcl_deliver {
      if (obj.hits > 0) {
            set resp.http.X-Cache = "HIT";
      } else {
            set resp.http.X-Cache = "MISS";
      }
}


{% if varnish_custom_503_filename is defined %}
# Used to provide a custom 503 error message that is styled
# like the rest of the site and more friendly in verbiage.
import std;
sub vcl_error {
      set obj.http.Content-Type = "text/html; charset=utf-8";

      if (obj.status == 503) {
          set obj.http.error503 = std.fileread("{{ varnish_custom_503_filename }}");
          synthetic obj.http.error503;
          return(deliver);
      }
}
{% endif %}
